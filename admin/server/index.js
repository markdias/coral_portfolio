import express from 'express';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import fs from 'node:fs/promises';
import dotenv from 'dotenv';
import { pathToFileURL } from 'node:url';
import multer from 'multer';
import sharp from 'sharp';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
app.disable('x-powered-by');
app.use(express.json({ limit: '2mb' }));
// Serve images so admin can preview uploaded files
app.use('/images', express.static(path.resolve(__dirname, '../../frontend/public/images')));

const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || '';

// Only allow localhost access
app.use((req, res, next) => {
  const ip = req.ip || '';
  // Express may give ::1 for IPv6 localhost
  const isLocal = ip === '127.0.0.1' || ip === '::1' || ip === '::ffff:127.0.0.1';
  if (!isLocal) return res.status(403).send('Forbidden');
  next();
});

app.post('/api/publish', async (req, res) => {
  try {
    if (!ADMIN_PASSWORD) {
      return res.status(500).send('Server not configured with ADMIN_PASSWORD');
    }

    const headerPassword = req.header('x-admin-password') || '';
    if (headerPassword !== ADMIN_PASSWORD) {
      return res.status(401).send('Unauthorized');
    }

    const { data } = req.body || {};
    if (!data || typeof data !== 'object') {
      return res.status(400).send('Invalid data payload');
    }

    // Inject a content version to invalidate frontend local caches
    const withVersion = {
      ...data,
      settings: {
        ...(data.settings || {}),
        __contentVersion: Date.now()
      }
    };

    const jsModule = `// Generated by Admin publish on ${new Date().toISOString()}\n` +
      `export const defaultData = ${JSON.stringify(withVersion, null, 2)};\n\n` +
      `export const getDefaultData = () => JSON.parse(JSON.stringify(defaultData));\n`;

    const targetPath = path.resolve(__dirname, '../../frontend/src/data/defaultData.js');
    // Ensure directory exists
    await fs.mkdir(path.dirname(targetPath), { recursive: true });
    await fs.writeFile(targetPath, jsModule, 'utf8');

    return res.status(200).json({ ok: true, path: targetPath });
  } catch (err) {
    console.error(err);
    return res.status(500).send('Publish failed');
  }
});

// Read current frontend dataset so the admin can pick up existing content
app.get('/api/current', async (req, res) => {
  try {
    const targetPath = path.resolve(__dirname, '../../frontend/src/data/defaultData.js');
    const url = pathToFileURL(targetPath).href + `?t=${Date.now()}`; // bust import cache
    const mod = await import(url);
    const data = typeof mod.getDefaultData === 'function' ? mod.getDefaultData() : mod.defaultData;
    return res.json({ data });
  } catch (err) {
    console.error('Failed to load current frontend data', err);
    return res.status(500).send('Unable to read current data');
  }
});

// Helper: ensure a directory exists
async function ensureDir(dir) {
  await fs.mkdir(dir, { recursive: true });
}

// Helper: remove directory recursively if it exists
async function removeDir(dir) {
  try {
    await fs.rm(dir, { recursive: true, force: true });
  } catch (_) {}
}

function requireAdmin(req, res, next) {
  if (!ADMIN_PASSWORD) return res.status(500).send('Server not configured with ADMIN_PASSWORD');
  const headerPassword = req.header('x-admin-password') || '';
  if (headerPassword !== ADMIN_PASSWORD) return res.status(401).send('Unauthorized');
  return next();
}

// Initialize base images folders for sections and categories
app.post('/api/media/init', requireAdmin, async (req, res) => {
  try {
    const imagesRoot = path.resolve(__dirname, '../../frontend/public/images');
    await ensureDir(imagesRoot);
    await Promise.all([
      ensureDir(path.join(imagesRoot, 'home')),
      ensureDir(path.join(imagesRoot, 'about')),
      ensureDir(path.join(imagesRoot, 'portfolio')),
      ensureDir(path.join(imagesRoot, 'collections')),
      ensureDir(path.join(imagesRoot, 'projects'))
    ]);
    res.json({ ok: true, root: imagesRoot });
  } catch (err) {
    console.error('media init failed', err);
    res.status(500).send('Init failed');
  }
});

// Create/remove collection media folders
app.post('/api/media/collection/:id', requireAdmin, async (req, res) => {
  const { id } = req.params;
  try {
    const dir = path.resolve(__dirname, `../../frontend/public/images/collections/${id}`);
    await ensureDir(dir);
    res.json({ ok: true, dir });
  } catch (err) {
    console.error('create collection dir failed', err);
    res.status(500).send('Create collection dir failed');
  }
});

app.delete('/api/media/collection/:id', requireAdmin, async (req, res) => {
  const { id } = req.params;
  try {
    const dir = path.resolve(__dirname, `../../frontend/public/images/collections/${id}`);
    await removeDir(dir);
    res.json({ ok: true, dir });
  } catch (err) {
    console.error('remove collection dir failed', err);
    res.status(500).send('Remove collection dir failed');
  }
});

// Create/remove project media folders
app.post('/api/media/project/:id', requireAdmin, async (req, res) => {
  const { id } = req.params;
  try {
    const dir = path.resolve(__dirname, `../../frontend/public/images/projects/${id}`);
    await ensureDir(dir);
    res.json({ ok: true, dir });
  } catch (err) {
    console.error('create project dir failed', err);
    res.status(500).send('Create project dir failed');
  }
});

app.delete('/api/media/project/:id', requireAdmin, async (req, res) => {
  const { id } = req.params;
  try {
    const dir = path.resolve(__dirname, `../../frontend/public/images/projects/${id}`);
    await removeDir(dir);
    res.json({ ok: true, dir });
  } catch (err) {
    console.error('remove project dir failed', err);
    res.status(500).send('Remove project dir failed');
  }
});

// Upload handler using multer, destination depends on query params
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const scope = (req.query.scope || '').toString(); // 'projects' | 'collections' | 'home' | 'about' | 'portfolio'
    const parentId = (req.query.parentId || '').toString();
    const imagesRoot = path.resolve(__dirname, '../../frontend/public/images');
    let dest = imagesRoot;
    if (scope) dest = path.join(dest, scope);
    if (parentId) dest = path.join(dest, parentId);
    fs.mkdir(dest, { recursive: true }).then(() => cb(null, dest)).catch((err) => cb(err, ''));
  },
  filename: (req, file, cb) => {
    const safe = file.originalname.replace(/[^a-zA-Z0-9._-]/g, '_');
    const stamp = Date.now();
    const ext = path.extname(safe);
    const base = path.basename(safe, ext);
    cb(null, `${base}-${stamp}${ext || ''}`);
  }
});

const upload = multer({ storage });

const clampNumber = (value, min, max, fallback) => {
  const number = Number(value);
  if (!Number.isFinite(number)) return fallback;
  return Math.min(Math.max(number, min), max);
};

const escapeForSvg = (value) =>
  (value || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');

const parseWatermarkSettings = (input) => {
  if (!input) return { enabled: false, text: '', opacity: 0.08, scale: 1 };
  try {
    const parsed = typeof input === 'string' ? JSON.parse(input) : input;
    return {
      enabled: Boolean(parsed?.enabled),
      text: typeof parsed?.text === 'string' ? parsed.text : '',
      opacity: clampNumber(parsed?.opacity, 0, 1, 0.08),
      scale: clampNumber(parsed?.scale, 0.25, 4, 1)
    };
  } catch (_) {
    return { enabled: false, text: '', opacity: 0.08, scale: 1 };
  }
};

async function applyWatermark(filePath, watermark) {
  const text = watermark.text?.trim();
  if (!watermark.enabled || !text) return;

  const metadata = await sharp(filePath).metadata();
  const { width, height } = metadata;

  if (!width || !height) return;

  const shortestSide = Math.min(width, height);
  const tileSize = Math.max(160, Math.round((shortestSide / 3) * watermark.scale));
  const fontSize = Math.max(24, Math.round((shortestSide / 12) * watermark.scale));
  const fill = `rgba(255, 255, 255, ${watermark.opacity})`;

  const svg = `<?xml version="1.0" encoding="UTF-8"?>` +
    `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">` +
    `<defs>` +
    `<pattern id="watermark-pattern" patternUnits="userSpaceOnUse" width="${tileSize}" height="${tileSize}">` +
    `<text x="${tileSize / 2}" y="${tileSize / 2}" text-anchor="middle" dominant-baseline="middle" font-family="'Helvetica Neue', Helvetica, Arial, sans-serif" font-size="${fontSize}" font-weight="600" fill="${fill}" opacity="${watermark.opacity}" transform="rotate(-30 ${tileSize / 2} ${tileSize / 2})">${escapeForSvg(text)}</text>` +
    `</pattern>` +
    `</defs>` +
    `<rect width="100%" height="100%" fill="url(#watermark-pattern)" />` +
    `</svg>`;

  const buffer = await sharp(filePath)
    .composite([{ input: Buffer.from(svg) }])
    .toBuffer();

  await fs.writeFile(filePath, buffer);
}

app.post('/api/media/upload', requireAdmin, upload.single('file'), async (req, res) => {
  try {
    const scope = (req.query.scope || '').toString();
    const parentId = (req.query.parentId || '').toString();
    const filename = req.file?.filename;
    if (!filename) return res.status(400).send('No file uploaded');

    const destination = req.file?.destination;
    const filePath = destination ? path.join(destination, filename) : req.file?.path;
    const watermark = parseWatermarkSettings(req.body?.watermark);

    if (filePath && req.file?.mimetype?.startsWith('image/') && watermark.enabled) {
      await applyWatermark(filePath, watermark);
    }

    const parts = ['/images'];
    if (scope) parts.push(scope);
    if (parentId) parts.push(parentId);
    parts.push(filename);
    const publicPath = parts.join('/');
    return res.json({ ok: true, path: publicPath });
  } catch (err) {
    console.error('upload failed', err);
    return res.status(500).send('Upload failed');
  }
});

const HOST = process.env.ADMIN_API_HOST || '127.0.0.1';
const PORT = Number(process.env.ADMIN_API_PORT) || 5175;
app.listen(PORT, HOST, () => {
  console.log(`Admin API listening on http://${HOST}:${PORT}`);
});
