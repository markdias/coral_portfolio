import express from 'express';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import fs from 'node:fs/promises';
import dotenv from 'dotenv';
import { pathToFileURL } from 'node:url';
import multer from 'multer';
import sharp from 'sharp';
import { exec } from 'node:child_process';
import { promisify } from 'node:util';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
app.disable('x-powered-by');
app.use(express.json({ limit: '2mb' }));
// Serve images so admin can preview uploaded files
app.use('/images', express.static(path.resolve(__dirname, '../../frontend/public/images')));

const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || '';
const execAsync = promisify(exec);
const repoRoot = path.resolve(__dirname, '../..');

async function runGit(command) {
  try {
    const { stdout, stderr } = await execAsync(command, { cwd: repoRoot });
    return { ok: true, stdout: stdout?.trim?.() ?? '', stderr: stderr?.trim?.() ?? '' };
  } catch (error) {
    return {
      ok: false,
      stdout: error?.stdout?.trim?.() ?? '',
      stderr: error?.stderr?.trim?.() ?? '',
      message: error?.message || 'Command failed'
    };
  }
}

// Only allow localhost access
app.use((req, res, next) => {
  const ip = req.ip || '';
  // Express may give ::1 for IPv6 localhost
  const isLocal = ip === '127.0.0.1' || ip === '::1' || ip === '::ffff:127.0.0.1';
  if (!isLocal) return res.status(403).send('Forbidden');
  next();
});

app.post('/api/publish', async (req, res) => {
  try {
    if (!ADMIN_PASSWORD) {
      return res.status(500).send('Server not configured with ADMIN_PASSWORD');
    }

    const headerPassword = req.header('x-admin-password') || '';
    if (headerPassword !== ADMIN_PASSWORD) {
      return res.status(401).send('Unauthorized');
    }

    const { data } = req.body || {};
    if (!data || typeof data !== 'object') {
      return res.status(400).send('Invalid data payload');
    }

    // Inject a content version to invalidate frontend local caches
    const withVersion = {
      ...data,
      settings: {
        ...(data.settings || {}),
        __contentVersion: Date.now()
      }
    };

    const jsModule = `// Generated by Admin publish on ${new Date().toISOString()}\n` +
      `export const defaultData = ${JSON.stringify(withVersion, null, 2)};\n\n` +
      `export const getDefaultData = () => JSON.parse(JSON.stringify(defaultData));\n`;

    const targetPath = path.resolve(__dirname, '../../frontend/src/data/defaultData.js');
    // Ensure directory exists
    await fs.mkdir(path.dirname(targetPath), { recursive: true });
    await fs.writeFile(targetPath, jsModule, 'utf8');

    return res.status(200).json({ ok: true, path: targetPath });
  } catch (err) {
    console.error(err);
    return res.status(500).send('Publish failed');
  }
});

// Read current frontend dataset so the admin can pick up existing content
app.get('/api/current', async (req, res) => {
  try {
    const targetPath = path.resolve(__dirname, '../../frontend/src/data/defaultData.js');
    const url = pathToFileURL(targetPath).href + `?t=${Date.now()}`; // bust import cache
    const mod = await import(url);
    const data = typeof mod.getDefaultData === 'function' ? mod.getDefaultData() : mod.defaultData;
    return res.json({ data });
  } catch (err) {
    console.error('Failed to load current frontend data', err);
    return res.status(500).send('Unable to read current data');
  }
});

// Helper: ensure a directory exists
async function ensureDir(dir) {
  await fs.mkdir(dir, { recursive: true });
}

// Helper: remove directory recursively if it exists
async function removeDir(dir) {
  try {
    await fs.rm(dir, { recursive: true, force: true });
  } catch (_) {}
}

function requireAdmin(req, res, next) {
  if (!ADMIN_PASSWORD) return res.status(500).send('Server not configured with ADMIN_PASSWORD');
  const headerPassword = req.header('x-admin-password') || '';
  if (headerPassword !== ADMIN_PASSWORD) return res.status(401).send('Unauthorized');
  return next();
}

// Initialize base images folders for sections and categories
app.post('/api/media/init', requireAdmin, async (req, res) => {
  try {
    const imagesRoot = path.resolve(__dirname, '../../frontend/public/images');
    await ensureDir(imagesRoot);
    await Promise.all([
      ensureDir(path.join(imagesRoot, 'home')),
      ensureDir(path.join(imagesRoot, 'about')),
      ensureDir(path.join(imagesRoot, 'portfolio')),
      ensureDir(path.join(imagesRoot, 'collections')),
      ensureDir(path.join(imagesRoot, 'projects'))
    ]);
    res.json({ ok: true, root: imagesRoot });
  } catch (err) {
    console.error('media init failed', err);
    res.status(500).send('Init failed');
  }
});

app.get('/api/git/branches', requireAdmin, async (req, res) => {
  try {
    const currentBranchResult = await runGit('git rev-parse --abbrev-ref HEAD');
    if (!currentBranchResult.ok) {
      throw new Error(currentBranchResult.message || 'Unable to resolve current branch');
    }

    const branchListResult = await runGit('git branch --format="%(refname:short)"');
    if (!branchListResult.ok) {
      throw new Error(branchListResult.message || 'Unable to list branches');
    }

    const branches = branchListResult.stdout
      .split('\n')
      .map((name) => name.trim())
      .filter(Boolean)
      .sort((a, b) => a.localeCompare(b));

    return res.json({
      ok: true,
      branches,
      current: currentBranchResult.stdout.trim()
    });
  } catch (error) {
    return res.status(500).json({
      ok: false,
      error: error?.message || 'Failed to read branches'
    });
  }
});

app.post('/api/git/commit-sync', requireAdmin, async (req, res) => {
  const { branchName, commitMessage } = req.body || {};
  const logs = [];

  const sanitizedBranch = typeof branchName === 'string' ? branchName.trim() : '';
  const sanitizedMessage = typeof commitMessage === 'string' ? commitMessage.trim() : '';

  if (!sanitizedBranch || !/^[A-Za-z0-9._\-/]+$/.test(sanitizedBranch)) {
    return res.status(400).json({
      ok: false,
      error: 'A valid branch name is required (letters, numbers, ".", "-", "_", and "/" only).'
    });
  }

  if (!sanitizedMessage) {
    return res.status(400).json({ ok: false, error: 'A commit message is required.' });
  }

  let startingBranch = null;
  let changedBranch = false;

  try {
    const statusResult = await runGit('git status --porcelain');
    logs.push({ step: 'Check working tree', command: 'git status --porcelain', ...statusResult });
    if (!statusResult.ok) {
      throw new Error(statusResult.message || 'Unable to inspect repository status');
    }
    if (!statusResult.stdout) {
      return res.status(400).json({
        ok: false,
        error: 'No changes detected to commit.',
        steps: logs
      });
    }

    const currentBranchResult = await runGit('git rev-parse --abbrev-ref HEAD');
    logs.push({ step: 'Resolve current branch', command: 'git rev-parse --abbrev-ref HEAD', ...currentBranchResult });
    if (!currentBranchResult.ok) {
      throw new Error(currentBranchResult.message || 'Unable to read current branch');
    }
    startingBranch = currentBranchResult.stdout || 'main';

    const branchCheckResult = await runGit(`git rev-parse --verify ${sanitizedBranch}`);
    logs.push({ step: 'Check if branch exists', command: `git rev-parse --verify ${sanitizedBranch}`, ...branchCheckResult });

    if (!branchCheckResult.ok) {
      const checkoutNewResult = await runGit(`git checkout -b ${sanitizedBranch}`);
      logs.push({ step: 'Create branch', command: `git checkout -b ${sanitizedBranch}`, ...checkoutNewResult });
      if (!checkoutNewResult.ok) {
        throw new Error(checkoutNewResult.message || 'Failed to create branch');
      }
      changedBranch = true;
    } else {
      const checkoutExistingResult = await runGit(`git checkout ${sanitizedBranch}`);
      logs.push({ step: 'Switch to branch', command: `git checkout ${sanitizedBranch}`, ...checkoutExistingResult });
      if (!checkoutExistingResult.ok) {
        throw new Error(checkoutExistingResult.message || 'Failed to switch to branch');
      }
      if (startingBranch !== sanitizedBranch) {
        changedBranch = true;
      }
    }

    const addResult = await runGit('git add -A');
    logs.push({ step: 'Stage changes', command: 'git add -A', ...addResult });
    if (!addResult.ok) {
      throw new Error(addResult.message || 'Failed to stage changes');
    }

    const commitResult = await runGit(`git commit -m ${JSON.stringify(sanitizedMessage)}`);
    logs.push({ step: 'Commit changes', command: `git commit -m ${JSON.stringify(sanitizedMessage)}`, ...commitResult });
    if (!commitResult.ok) {
      throw new Error(commitResult.message || 'Failed to commit changes');
    }

    const pushResult = await runGit(`git push -u origin ${sanitizedBranch}`);
    logs.push({ step: 'Push branch', command: `git push -u origin ${sanitizedBranch}`, ...pushResult });
    if (!pushResult.ok) {
      throw new Error(pushResult.message || 'Failed to push branch');
    }

    return res.json({ ok: true, steps: logs, branch: sanitizedBranch, startingBranch });
  } catch (error) {
    if (changedBranch && startingBranch && sanitizedBranch !== startingBranch) {
      const restoreResult = await runGit(`git checkout ${startingBranch}`);
      logs.push({ step: 'Restore starting branch', command: `git checkout ${startingBranch}`, ...restoreResult });
    }

    return res.status(500).json({
      ok: false,
      error: error?.message || 'Git operation failed',
      steps: logs
    });
  }
});

// Create/remove collection media folders
app.post('/api/media/collection/:id', requireAdmin, async (req, res) => {
  const { id } = req.params;
  try {
    const dir = path.resolve(__dirname, `../../frontend/public/images/collections/${id}`);
    await ensureDir(dir);
    res.json({ ok: true, dir });
  } catch (err) {
    console.error('create collection dir failed', err);
    res.status(500).send('Create collection dir failed');
  }
});

app.delete('/api/media/collection/:id', requireAdmin, async (req, res) => {
  const { id } = req.params;
  try {
    const dir = path.resolve(__dirname, `../../frontend/public/images/collections/${id}`);
    await removeDir(dir);
    res.json({ ok: true, dir });
  } catch (err) {
    console.error('remove collection dir failed', err);
    res.status(500).send('Remove collection dir failed');
  }
});

// Create/remove project media folders
app.post('/api/media/project/:id', requireAdmin, async (req, res) => {
  const { id } = req.params;
  try {
    const dir = path.resolve(__dirname, `../../frontend/public/images/projects/${id}`);
    await ensureDir(dir);
    res.json({ ok: true, dir });
  } catch (err) {
    console.error('create project dir failed', err);
    res.status(500).send('Create project dir failed');
  }
});

app.delete('/api/media/project/:id', requireAdmin, async (req, res) => {
  const { id } = req.params;
  try {
    const dir = path.resolve(__dirname, `../../frontend/public/images/projects/${id}`);
    await removeDir(dir);
    res.json({ ok: true, dir });
  } catch (err) {
    console.error('remove project dir failed', err);
    res.status(500).send('Remove project dir failed');
  }
});

// Upload handler using multer, destination depends on query params
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const scope = (req.query.scope || '').toString(); // 'projects' | 'collections' | 'home' | 'about' | 'portfolio'
    const parentId = (req.query.parentId || '').toString();
    const imagesRoot = path.resolve(__dirname, '../../frontend/public/images');
    let dest = imagesRoot;
    if (scope) dest = path.join(dest, scope);
    if (parentId) dest = path.join(dest, parentId);
    fs.mkdir(dest, { recursive: true }).then(() => cb(null, dest)).catch((err) => cb(err, ''));
  },
  filename: (req, file, cb) => {
    const safe = file.originalname.replace(/[^a-zA-Z0-9._-]/g, '_');
    const stamp = Date.now();
    const ext = path.extname(safe);
    const base = path.basename(safe, ext);
    cb(null, `${base}-${stamp}${ext || ''}`);
  }
});

const upload = multer({ storage });

const clampNumber = (value, min, max, fallback) => {
  const number = Number(value);
  if (!Number.isFinite(number)) return fallback;
  return Math.min(Math.max(number, min), max);
};

const escapeForSvg = (value) =>
  (value || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');

const parseWatermarkSettings = (input) => {
  if (!input) return { enabled: false, text: '', opacity: 0.08, scale: 1 };
  try {
    const parsed = typeof input === 'string' ? JSON.parse(input) : input;
    return {
      enabled: Boolean(parsed?.enabled),
      text: typeof parsed?.text === 'string' ? parsed.text : '',
      opacity: clampNumber(parsed?.opacity, 0, 1, 0.08),
      scale: clampNumber(parsed?.scale, 0.25, 4, 1)
    };
  } catch (_) {
    return { enabled: false, text: '', opacity: 0.08, scale: 1 };
  }
};

async function applyWatermark(filePath, watermark) {
  const text = watermark.text?.trim();
  if (!watermark.enabled || !text) return;

  const metadata = await sharp(filePath).metadata();
  const { width, height } = metadata;

  if (!width || !height) return;

  const shortestSide = Math.min(width, height);
  const tileSize = Math.max(160, Math.round((shortestSide / 3) * watermark.scale));
  const fontSize = Math.max(24, Math.round((shortestSide / 12) * watermark.scale));
  const fill = `rgba(255, 255, 255, ${watermark.opacity})`;

  const svg = `<?xml version="1.0" encoding="UTF-8"?>` +
    `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">` +
    `<defs>` +
    `<pattern id="watermark-pattern" patternUnits="userSpaceOnUse" width="${tileSize}" height="${tileSize}">` +
    `<text x="${tileSize / 2}" y="${tileSize / 2}" text-anchor="middle" dominant-baseline="middle" font-family="'Helvetica Neue', Helvetica, Arial, sans-serif" font-size="${fontSize}" font-weight="600" fill="${fill}" opacity="${watermark.opacity}" transform="rotate(-30 ${tileSize / 2} ${tileSize / 2})">${escapeForSvg(text)}</text>` +
    `</pattern>` +
    `</defs>` +
    `<rect width="100%" height="100%" fill="url(#watermark-pattern)" />` +
    `</svg>`;

  const buffer = await sharp(filePath)
    .composite([{ input: Buffer.from(svg) }])
    .toBuffer();

  await fs.writeFile(filePath, buffer);
}

app.post('/api/media/upload', requireAdmin, upload.single('file'), async (req, res) => {
  try {
    const scope = (req.query.scope || '').toString();
    const parentId = (req.query.parentId || '').toString();
    const filename = req.file?.filename;
    if (!filename) return res.status(400).send('No file uploaded');

    const destination = req.file?.destination;
    const filePath = destination ? path.join(destination, filename) : req.file?.path;
    const watermark = parseWatermarkSettings(req.body?.watermark);

    if (filePath && req.file?.mimetype?.startsWith('image/') && watermark.enabled) {
      await applyWatermark(filePath, watermark);
    }

    const parts = ['/images'];
    if (scope) parts.push(scope);
    if (parentId) parts.push(parentId);
    parts.push(filename);
    const publicPath = parts.join('/');
    return res.json({ ok: true, path: publicPath });
  } catch (err) {
    console.error('upload failed', err);
    return res.status(500).send('Upload failed');
  }
});

const HOST = process.env.ADMIN_API_HOST || '127.0.0.1';
const PORT = Number(process.env.ADMIN_API_PORT) || 5175;
app.listen(PORT, HOST, () => {
  console.log(`Admin API listening on http://${HOST}:${PORT}`);
});
